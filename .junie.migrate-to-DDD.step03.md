## üë§ Task 3: Phase 3 - User Domain Migration (5-7 days)

### üéØ Task 3.1: Create User Domain Value Objects
src/lib/user/domain/value-objects/user-id.vo.ts:

```typescript
import {ValueObject} from '@/lib/shared/domain/interfaces/value-object.interface';

export class UserId extends ValueObject {
    constructor(private readonly value: string) {
        super();
        if (!value || value.trim().length === 0) {
            throw new Error('UserId cannot be empty');
        }
    }

    getValue(): string {
        return this.value;
    }

    equals(other: ValueObject): boolean {
        return other instanceof UserId && this.value === other.value;
    }

    toString(): string {
        return this.value;
    }

    static create(value: string): UserId {
        return new UserId(value);
    }

    static generate(): UserId {
        return new UserId(crypto.randomUUID());
    }
}
```

src/lib/user/domain/value-objects/email.vo.ts:

```typescript
import {ValueObject} from '@/lib/shared/domain/interfaces/value-object.interface';

export class Email extends ValueObject {
    private static readonly EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    constructor(private readonly value: string) {
        super();
        if (!Email.EMAIL_REGEX.test(value)) {
            throw new Error(`Invalid email format: ${value}`);
        }
    }

    getValue(): string {
        return this.value;
    }

    equals(other: ValueObject): boolean {
        return other instanceof Email && this.value === other.value;
    }

    toString(): string {
        return this.value;
    }

    static create(value: string): Email {
        return new Email(value.toLowerCase().trim());
    }
}
```

src/lib/user/domain/value-objects/password.vo.ts:

```typescript
import {ValueObject} from '@/lib/shared/domain/interfaces/value-object.interface';

export class Password extends ValueObject {
    private static readonly MIN_LENGTH = 8;
    private static readonly REQUIRES_UPPERCASE = true;
    private static readonly REQUIRES_LOWERCASE = true;
    private static readonly REQUIRES_NUMBER = true;
    private static readonly REQUIRES_SPECIAL = true;

    private readonly value: string;
    private readonly isHashed: boolean;

    private constructor(value: string, isHashed: boolean = false) {
        super();
        this.value = value;
        this.isHashed = isHashed;
    }

    getValue(): string {
        return this.value;
    }

    isAlreadyHashed(): boolean {
        return this.isHashed;
    }

    equals(other: ValueObject): boolean {
        return other instanceof Password && this.value === other.value;
    }

    static createHashed(hashedValue: string): Password {
        return new Password(hashedValue, true);
    }

    static create(plainValue: string): Password {
        Password.validate(plainValue);
        return new Password(plainValue, false);
    }

    private static validate(value: string): void {
        if (value.length < Password.MIN_LENGTH) {
            throw new Error(`Password must be at least ${Password.MIN_LENGTH} characters long`);
        }

        if (Password.REQUIRES_UPPERCASE && !/[A-Z]/.test(value)) {
            throw new Error('Password must contain at least one uppercase letter');
        }

        if (Password.REQUIRES_LOWERCASE && !/[a-z]/.test(value)) {
            throw new Error('Password must contain at least one lowercase letter');
        }

        if (Password.REQUIRES_NUMBER && !/\d/.test(value)) {
            throw new Error('Password must contain at least one number');
        }

        if (Password.REQUIRES_SPECIAL && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(value)) {
            throw new Error('Password must contain at least one special character');
        }
    }
}
```

src/lib/user/domain/value-objects/user-role.vo.ts:

```typescript
import {ValueObject} from '@/lib/shared/domain/interfaces/value-object.interface';

export enum UserRoleEnum {
    ADMIN = 'ADMIN',
    USER = 'USER',
    GUEST = 'GUEST'
}

export class UserRole extends ValueObject {
    constructor(private readonly value: UserRoleEnum) {
        super();
    }

    getValue(): UserRoleEnum {
        return this.value;
    }

    equals(other: ValueObject): boolean {
        return other instanceof UserRole && this.value === other.value;
    }

    isAdmin(): boolean {
        return this.value === UserRoleEnum.ADMIN;
    }

    isUser(): boolean {
        return this.value === UserRoleEnum.USER;
    }

    isGuest(): boolean {
        return this.value === UserRoleEnum.GUEST;
    }

    toString(): string {
        return this.value;
    }

    static create(value: string): UserRole {
        if (!Object.values(UserRoleEnum).includes(value as UserRoleEnum)) {
            throw new Error(`Invalid user role: ${value}`);
        }
        return new UserRole(value as UserRoleEnum);
    }

    static admin(): UserRole {
        return new UserRole(UserRoleEnum.ADMIN);
    }

    static user(): UserRole {
        return new UserRole(UserRoleEnum.USER);
    }

    static guest(): UserRole {
        return new UserRole(UserRoleEnum.GUEST);
    }
}
```

### üß© Task 3.2: Create User Domain Entities
src/lib/user/domain/entities/user.entity.ts:

```typescript
import {Entity} from '@/lib/shared/domain/interfaces/entity.interface';
import {UserId} from '../value-objects/user-id.vo';
import {Email} from '../value-objects/email.vo';
import {Password} from '../value-objects/password.vo';
import {UserRole} from '../value-objects/user-role.vo';

export class User extends Entity<UserId> {
    constructor(
        id: UserId,
        private email: Email,
        private password: Password,
        private role: UserRole,
        private readonly createdAt: Date,
        private updatedAt: Date,
        private lastLoginAt: Date | null = null,
        private active: boolean = true
    ) {
        super(id);
    }

    getId(): UserId {
        return this.id;
    }

    getEmail(): Email {
        return this.email;
    }

    getPassword(): Password {
        return this.password;
    }

    getRole(): UserRole {
        return this.role;
    }

    getCreatedAt(): Date {
        return this.createdAt;
    }

    getUpdatedAt(): Date {
        return this.updatedAt;
    }

    getLastLoginAt(): Date | null {
        return this.lastLoginAt;
    }

    isActive(): boolean {
        return this.active;
    }

    updateEmail(email: Email): void {
        this.email = email;
        this.updatedAt = new Date();
    }

    updatePassword(password: Password): void {
        this.password = password;
        this.updatedAt = new Date();
    }

    updateRole(role: UserRole): void {
        this.role = role;
        this.updatedAt = new Date();
    }

    recordLogin(): void {
        this.lastLoginAt = new Date();
        this.updatedAt = new Date();
    }

    activate(): void {
        this.active = true;
        this.updatedAt = new Date();
    }

    deactivate(): void {
        this.active = false;
        this.updatedAt = new Date();
    }

    static create(
        id: UserId,
        email: Email,
        password: Password,
        role: UserRole
    ): User {
        const now = new Date();
        return new User(id, email, password, role, now, now);
    }
}
```

src/lib/user/domain/entities/user-session.entity.ts:

```typescript
import {Entity} from '@/lib/shared/domain/interfaces/entity.interface';
import {UserId} from '../value-objects/user-id.vo';

export class SessionId {
    constructor(private readonly value: string) {
        if (!value || value.trim().length === 0) {
            throw new Error('SessionId cannot be empty');
        }
    }

    getValue(): string {
        return this.value;
    }

    equals(other: SessionId): boolean {
        return this.value === other.value;
    }

    toString(): string {
        return this.value;
    }

    static create(value: string): SessionId {
        return new SessionId(value);
    }

    static generate(): SessionId {
        return new SessionId(crypto.randomUUID());
    }
}

export class UserSession extends Entity<SessionId> {
    constructor(
        id: SessionId,
        private readonly userId: UserId,
        private readonly token: string,
        private readonly expiresAt: Date,
        private readonly createdAt: Date,
        private readonly ipAddress: string,
        private readonly userAgent: string,
        private revoked: boolean = false
    ) {
        super(id);
    }

    getId(): SessionId {
        return this.id;
    }

    getUserId(): UserId {
        return this.userId;
    }

    getToken(): string {
        return this.token;
    }

    getExpiresAt(): Date {
        return this.expiresAt;
    }

    getCreatedAt(): Date {
        return this.createdAt;
    }

    getIpAddress(): string {
        return this.ipAddress;
    }

    getUserAgent(): string {
        return this.userAgent;
    }

    isRevoked(): boolean {
        return this.revoked;
    }

    isExpired(): boolean {
        return new Date() > this.expiresAt;
    }

    isValid(): boolean {
        return !this.isRevoked() && !this.isExpired();
    }

    revoke(): void {
        this.revoked = true;
    }

    static create(
        userId: UserId,
        token: string,
        expiresAt: Date,
        ipAddress: string,
        userAgent: string
    ): UserSession {
        return new UserSession(
            SessionId.generate(),
            userId,
            token,
            expiresAt,
            new Date(),
            ipAddress,
            userAgent
        );
    }
}
```

### üîê Task 3.3: Create User Domain Services
src/lib/user/domain/services/password-hasher.ts:

```typescript
import {Password} from '../value-objects/password.vo';

export interface PasswordHasher {
    hash(password: Password): Promise<Password>;
    compare(plainPassword: Password, hashedPassword: Password): Promise<boolean>;
}
```

src/lib/user/domain/services/user-authenticator.ts:

```typescript
import {User} from '../entities/user.entity';
import {Email} from '../value-objects/email.vo';
import {Password} from '../value-objects/password.vo';
import {UserRepository} from '../interfaces/user-repository.interface';
import {PasswordHasher} from './password-hasher';
import {InvalidCredentialsException} from '../exceptions/invalid-credentials.exception';
import {UserSession} from '../entities/user-session.entity';
import {SessionRepository} from '../interfaces/session-repository.interface';

export class UserAuthenticator {
    constructor(
        private readonly userRepository: UserRepository,
        private readonly sessionRepository: SessionRepository,
        private readonly passwordHasher: PasswordHasher,
        private readonly tokenGenerator: (user: User) => Promise<string>,
        private readonly sessionDuration: number = 24 * 60 * 60 * 1000 // 24 hours in milliseconds
    ) {}

    async authenticate(
        email: Email,
        password: Password,
        ipAddress: string,
        userAgent: string
    ): Promise<UserSession> {
        const user = await this.userRepository.findByEmail(email);
        
        if (!user) {
            throw new InvalidCredentialsException();
        }

        if (!user.isActive()) {
            throw new InvalidCredentialsException('User account is inactive');
        }

        const isPasswordValid = await this.passwordHasher.compare(
            password,
            user.getPassword()
        );

        if (!isPasswordValid) {
            throw new InvalidCredentialsException();
        }

        // Record login
        user.recordLogin();
        await this.userRepository.save(user);

        // Generate token
        const token = await this.tokenGenerator(user);
        
        // Calculate expiration
        const expiresAt = new Date();
        expiresAt.setTime(expiresAt.getTime() + this.sessionDuration);

        // Create session
        const session = UserSession.create(
            user.getId(),
            token,
            expiresAt,
            ipAddress,
            userAgent
        );

        // Save session
        await this.sessionRepository.save(session);

        return session;
    }

    async validateSession(token: string): Promise<User | null> {
        const session = await this.sessionRepository.findByToken(token);

        if (!session || !session.isValid()) {
            return null;
        }

        return this.userRepository.findById(session.getUserId());
    }

    async logout(token: string): Promise<void> {
        const session = await this.sessionRepository.findByToken(token);

        if (session && !session.isRevoked()) {
            session.revoke();
            await this.sessionRepository.save(session);
        }
    }
}
```

### üì¶ Task 3.4: Create User Domain Repositories
src/lib/user/domain/interfaces/user-repository.interface.ts:

```typescript
import {Repository} from '@/lib/shared/domain/interfaces/repository.interface';
import {User} from '../entities/user.entity';
import {UserId} from '../value-objects/user-id.vo';
import {Email} from '../value-objects/email.vo';

export interface UserRepository extends Repository<User, UserId> {
    findByEmail(email: Email): Promise<User | null>;
    emailExists(email: Email): Promise<boolean>;
}
```

src/lib/user/domain/interfaces/session-repository.interface.ts:

```typescript
import {Repository} from '@/lib/shared/domain/interfaces/repository.interface';
import {UserSession, SessionId} from '../entities/user-session.entity';
import {UserId} from '../value-objects/user-id.vo';

export interface SessionRepository extends Repository<UserSession, SessionId> {
    findByToken(token: string): Promise<UserSession | null>;
    findByUserId(userId: UserId): Promise<UserSession[]>;
    revokeAllForUser(userId: UserId): Promise<void>;
    cleanExpiredSessions(): Promise<void>;
}
```

### üîÑ Task 3.5: Create User Application Commands
src/lib/user/application/commands/register-user/register-user.command.ts:

```typescript
import {Command} from '@/lib/shared/application/interfaces/command.interface';

export class RegisterUserCommand implements Command {
    constructor(
        public readonly email: string,
        public readonly password: string,
        public readonly role: string = 'USER'
    ) {}
}
```

src/lib/user/application/commands/register-user/register-user.handler.ts:

```typescript
import {CommandHandler} from '@/lib/shared/application/interfaces/command.interface';
import {RegisterUserCommand} from './register-user.command';
import {UserRepository} from '@/lib/user/domain/interfaces/user-repository.interface';
import {PasswordHasher} from '@/lib/user/domain/services/password-hasher';
import {Email} from '@/lib/user/domain/value-objects/email.vo';
import {Password} from '@/lib/user/domain/value-objects/password.vo';
import {UserRole} from '@/lib/user/domain/value-objects/user-role.vo';
import {UserId} from '@/lib/user/domain/value-objects/user-id.vo';
import {User} from '@/lib/user/domain/entities/user.entity';
import {EmailAlreadyExistsException} from '@/lib/user/domain/exceptions/email-already-exists.exception';
import {EventBus} from '@/lib/shared/application/bus/event.bus';
import {UserRegisteredEvent} from '@/lib/user/domain/events/user-registered.event';

export class RegisterUserHandler implements CommandHandler<RegisterUserCommand> {
    constructor(
        private readonly userRepository: UserRepository,
        private readonly passwordHasher: PasswordHasher,
        private readonly eventBus: EventBus
    ) {}

    async handle(command: RegisterUserCommand): Promise<void> {
        const email = Email.create(command.email);
        const password = Password.create(command.password);
        const role = UserRole.create(command.role);

        // Check if email already exists
        const emailExists = await this.userRepository.emailExists(email);
        if (emailExists) {
            throw new EmailAlreadyExistsException(email.getValue());
        }

        // Hash password
        const hashedPassword = await this.passwordHasher.hash(password);

        // Create user
        const userId = UserId.generate();
        const user = User.create(userId, email, hashedPassword, role);

        // Save user
        await this.userRepository.save(user);

        // Publish event
        await this.eventBus.publish(new UserRegisteredEvent(
            userId.getValue(),
            email.getValue()
        ));
    }
}
```

src/lib/user/application/commands/authenticate-user/authenticate-user.command.ts:

```typescript
import {Command} from '@/lib/shared/application/interfaces/command.interface';

export class AuthenticateUserCommand implements Command {
    constructor(
        public readonly email: string,
        public readonly password: string,
        public readonly ipAddress: string,
        public readonly userAgent: string
    ) {}
}
```

src/lib/user/application/commands/authenticate-user/authenticate-user.handler.ts:

```typescript
import {CommandHandler} from '@/lib/shared/application/interfaces/command.interface';
import {AuthenticateUserCommand} from './authenticate-user.command';
import {UserAuthenticator} from '@/lib/user/domain/services/user-authenticator';
import {Email} from '@/lib/user/domain/value-objects/email.vo';
import {Password} from '@/lib/user/domain/value-objects/password.vo';
import {EventBus} from '@/lib/shared/application/bus/event.bus';
import {UserLoggedInEvent} from '@/lib/user/domain/events/user-logged-in.event';

export class AuthenticateUserHandler implements CommandHandler<AuthenticateUserCommand, string> {
    constructor(
        private readonly userAuthenticator: UserAuthenticator,
        private readonly eventBus: EventBus
    ) {}

    async handle(command: AuthenticateUserCommand): Promise<string> {
        const email = Email.create(command.email);
        const password = Password.create(command.password);

        const session = await this.userAuthenticator.authenticate(
            email,
            password,
            command.ipAddress,
            command.userAgent
        );

        // Publish event
        await this.eventBus.publish(new UserLoggedInEvent(
            session.getUserId().getValue(),
            session.getId().getValue(),
            command.ipAddress
        ));

        return session.getToken();
    }
}
```

### üîç Task 3.6: Create User Application Queries
src/lib/user/application/queries/get-current-user/get-current-user.query.ts:

```typescript
import {Query} from '@/lib/shared/application/interfaces/query.interface';

export class GetCurrentUserQuery implements Query<any> {
    constructor(
        public readonly token: string
    ) {}
}
```

src/lib/user/application/queries/get-current-user/get-current-user.handler.ts:

```typescript
import {QueryHandler} from '@/lib/shared/application/interfaces/query.interface';
import {GetCurrentUserQuery} from './get-current-user.query';
import {UserAuthenticator} from '@/lib/user/domain/services/user-authenticator';
import {UserMapper} from '@/lib/user/infrastructure/mappers/user.mapper';
import {SessionExpiredException} from '@/lib/user/domain/exceptions/session-expired.exception';

export class GetCurrentUserHandler implements QueryHandler<GetCurrentUserQuery, any> {
    constructor(
        private readonly userAuthenticator: UserAuthenticator
    ) {}

    async handle(query: GetCurrentUserQuery): Promise<any> {
        const user = await this.userAuthenticator.validateSession(query.token);

        if (!user) {
            throw new SessionExpiredException();
        }

        return UserMapper.toDTO(user);
    }
}
```

### üîå Task 3.7: Create User Infrastructure
src/lib/user/infrastructure/repositories/prisma-user.repository.ts:

```typescript
import {PrismaClient} from '@prisma/client';
import {UserRepository} from '@/lib/user/domain/interfaces/user-repository.interface';
import {User} from '@/lib/user/domain/entities/user.entity';
import {UserId} from '@/lib/user/domain/value-objects/user-id.vo';
import {Email} from '@/lib/user/domain/value-objects/email.vo';
import {UserMapper} from '../mappers/user.mapper';

export class PrismaUserRepository implements UserRepository {
    constructor(private readonly prisma: PrismaClient) {}

    async findById(id: UserId): Promise<User | null> {
        const userData = await this.prisma.user.findUnique({
            where: { id: id.getValue() }
        });

        return userData ? UserMapper.toDomain(userData) : null;
    }

    async findByEmail(email: Email): Promise<User | null> {
        const userData = await this.prisma.user.findUnique({
            where: { email: email.getValue() }
        });

        return userData ? UserMapper.toDomain(userData) : null;
    }

    async emailExists(email: Email): Promise<boolean> {
        const count = await this.prisma.user.count({
            where: { email: email.getValue() }
        });

        return count > 0;
    }

    async findAll(): Promise<User[]> {
        const users = await this.prisma.user.findMany();
        return users.map(UserMapper.toDomain);
    }

    async save(user: User): Promise<void> {
        const userData = UserMapper.toPersistence(user);

        await this.prisma.user.upsert({
            where: { id: userData.id },
            update: userData,
            create: userData
        });
    }

    async delete(id: UserId): Promise<void> {
        await this.prisma.user.delete({
            where: { id: id.getValue() }
        });
    }
}
```

src/lib/user/infrastructure/services/bcrypt-password-hasher.ts:

```typescript
import * as bcrypt from 'bcrypt';
import {PasswordHasher} from '@/lib/user/domain/services/password-hasher';
import {Password} from '@/lib/user/domain/value-objects/password.vo';

export class BcryptPasswordHasher implements PasswordHasher {
    constructor(private readonly saltRounds: number = 10) {}

    async hash(password: Password): Promise<Password> {
        if (password.isAlreadyHashed()) {
            return password;
        }

        const hashedValue = await bcrypt.hash(password.getValue(), this.saltRounds);
        return Password.createHashed(hashedValue);
    }

    async compare(plainPassword: Password, hashedPassword: Password): Promise<boolean> {
        return bcrypt.compare(plainPassword.getValue(), hashedPassword.getValue());
    }
}
```

src/lib/user/infrastructure/mappers/user.mapper.ts:

```typescript
import {User} from '@/lib/user/domain/entities/user.entity';
import {UserId} from '@/lib/user/domain/value-objects/user-id.vo';
import {Email} from '@/lib/user/domain/value-objects/email.vo';
import {Password} from '@/lib/user/domain/value-objects/password.vo';
import {UserRole} from '@/lib/user/domain/value-objects/user-role.vo';

// Define the shape of the user data in the database
interface UserPersistence {
    id: string;
    email: string;
    password: string;
    role: string;
    createdAt: Date;
    updatedAt: Date;
    lastLoginAt: Date | null;
    active: boolean;
}

// Define the shape of the user data for DTOs
interface UserDTO {
    id: string;
    email: string;
    role: string;
    createdAt: string;
    lastLoginAt: string | null;
    active: boolean;
}

export class UserMapper {
    static toDomain(persistence: UserPersistence): User {
        return new User(
            new UserId(persistence.id),
            new Email(persistence.email),
            Password.createHashed(persistence.password),
            new UserRole(persistence.role as any),
            persistence.createdAt,
            persistence.updatedAt,
            persistence.lastLoginAt,
            persistence.active
        );
    }

    static toPersistence(domain: User): UserPersistence {
        return {
            id: domain.getId().getValue(),
            email: domain.getEmail().getValue(),
            password: domain.getPassword().getValue(),
            role: domain.getRole().getValue(),
            createdAt: domain.getCreatedAt(),
            updatedAt: domain.getUpdatedAt(),
            lastLoginAt: domain.getLastLoginAt(),
            active: domain.isActive()
        };
    }

    static toDTO(domain: User): UserDTO {
        return {
            id: domain.getId().getValue(),
            email: domain.getEmail().getValue(),
            role: domain.getRole().getValue(),
            createdAt: domain.getCreatedAt().toISOString(),
            lastLoginAt: domain.getLastLoginAt()?.toISOString() || null,
            active: domain.isActive()
        };
    }
}
```

### üß™ Task 3.8: Create User Domain Tests
src/lib/user/domain/value-objects/tests/email.vo.test.ts:

```typescript
import {describe, it, expect} from 'vitest';
import {Email} from '../email.vo';

describe('Email Value Object', () => {
    it('should create a valid email', () => {
        const email = Email.create('test@example.com');
        expect(email.getValue()).toBe('test@example.com');
    });

    it('should throw an error for invalid email format', () => {
        expect(() => Email.create('invalid-email')).toThrow('Invalid email format');
    });

    it('should trim and lowercase email on creation', () => {
        const email = Email.create('  TEST@EXAMPLE.COM  ');
        expect(email.getValue()).toBe('test@example.com');
    });

    it('should correctly check equality', () => {
        const email1 = Email.create('test@example.com');
        const email2 = Email.create('test@example.com');
        const email3 = Email.create('other@example.com');

        expect(email1.equals(email2)).toBe(true);
        expect(email1.equals(email3)).toBe(false);
    });
});
```

src/lib/user/domain/entities/tests/user.entity.test.ts:

```typescript
import {describe, it, expect, beforeEach} from 'vitest';
import {User} from '../user.entity';
import {UserId} from '../../value-objects/user-id.vo';
import {Email} from '../../value-objects/email.vo';
import {Password} from '../../value-objects/password.vo';
import {UserRole, UserRoleEnum} from '../../value-objects/user-role.vo';

describe('User Entity', () => {
    let userId: UserId;
    let email: Email;
    let password: Password;
    let role: UserRole;
    let user: User;

    beforeEach(() => {
        userId = UserId.generate();
        email = Email.create('test@example.com');
        password = Password.createHashed('hashed_password');
        role = UserRole.user();
        user = User.create(userId, email, password, role);
    });

    it('should create a user with correct values', () => {
        expect(user.getId()).toBe(userId);
        expect(user.getEmail()).toBe(email);
        expect(user.getPassword()).toBe(password);
        expect(user.getRole()).toBe(role);
        expect(user.isActive()).toBe(true);
        expect(user.getLastLoginAt()).toBeNull();
    });

    it('should update email', () => {
        const newEmail = Email.create('new@example.com');
        user.updateEmail(newEmail);
        expect(user.getEmail()).toBe(newEmail);
    });

    it('should update password', () => {
        const newPassword = Password.createHashed('new_hashed_password');
        user.updatePassword(newPassword);
        expect(user.getPassword()).toBe(newPassword);
    });

    it('should update role', () => {
        const newRole = UserRole.admin();
        user.updateRole(newRole);
        expect(user.getRole()).toBe(newRole);
    });

    it('should record login', () => {
        expect(user.getLastLoginAt()).toBeNull();
        user.recordLogin();
        expect(user.getLastLoginAt()).toBeInstanceOf(Date);
    });

    it('should activate and deactivate user', () => {
        expect(user.isActive()).toBe(true);
        user.deactivate();
        expect(user.isActive()).toBe(false);
        user.activate();
        expect(user.isActive()).toBe(true);
    });
});
```

### ‚úÖ Task 3.9: Phase 3 Validation
Run tests:

```bash
npm run test src/lib/user/domain/
```

Integration test:

```typescript
// src/test/integration/phase-3.test.ts
import {describe, it, expect, beforeEach} from 'vitest';
import {PrismaClient} from '@prisma/client';
import {PrismaUserRepository} from '@/lib/user/infrastructure/repositories/prisma-user.repository';
import {BcryptPasswordHasher} from '@/lib/user/infrastructure/services/bcrypt-password-hasher';
import {RegisterUserHandler} from '@/lib/user/application/commands/register-user/register-user.handler';
import {RegisterUserCommand} from '@/lib/user/application/commands/register-user/register-user.command';
import {InMemoryEventBus} from '@/lib/shared/application/bus/event.bus';
import {Email} from '@/lib/user/domain/value-objects/email.vo';

describe('User Domain Integration', () => {
    let prisma: PrismaClient;
    let userRepository: PrismaUserRepository;
    let passwordHasher: BcryptPasswordHasher;
    let eventBus: InMemoryEventBus;
    let registerUserHandler: RegisterUserHandler;

    beforeEach(() => {
        prisma = new PrismaClient();
        userRepository = new PrismaUserRepository(prisma);
        passwordHasher = new BcryptPasswordHasher();
        eventBus = new InMemoryEventBus();
        registerUserHandler = new RegisterUserHandler(
            userRepository,
            passwordHasher,
            eventBus
        );
    });

    it('should register a new user', async () => {
        const email = `test-${Date.now()}@example.com`;
        const command = new RegisterUserCommand(
            email,
            'Password123!',
            'USER'
        );

        await registerUserHandler.handle(command);

        const user = await userRepository.findByEmail(Email.create(email));
        expect(user).not.toBeNull();
        expect(user?.getEmail().getValue()).toBe(email);
        expect(user?.getRole().getValue()).toBe('USER');
        expect(user?.isActive()).toBe(true);
    });
});
```

Checklist:

- User domain value objects created
- User domain entities created
- User domain services created
- User domain repositories created
- User application commands created
- User application queries created
- User infrastructure components created
- User domain tests created
- All tests passing
- Integration test passes